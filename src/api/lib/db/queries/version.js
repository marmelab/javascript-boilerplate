// @TODO refactor version to other base queries and hasChanges directly.

export default (client, table, historyTable, fields, idFieldName, idAutoGenerated) => {
    const updateLastVersion = function* updateLastVersion(entity) {
        const { parameters, setQuery } = fields.reduce((result, field) => {
            if (idAutoGenerated && field === 'id') return result;
            if (typeof entity[field] === 'undefined') return result;

            let value = entity[field];
            if (Array.isArray(entity[field])) {
                value = JSON.stringify(entity[field]);
            }

            const params = {};
            params[field] = value;
            return ({
                parameters: Object.assign({}, result.parameters, params),
                setQuery: [...result.setQuery, `${field}=$${field}`],
            });
        }, { parameters: {}, setQuery: [] });

        parameters[idFieldName] = entity.id;

        setQuery.push('versioned_at=$versionedAt');
        parameters.versionedAt = new Date();

        if (parameters.length === 1) {
            throw new Error('no valid column to set');
        }

        const query = `
            UPDATE ${historyTable}
            SET ${setQuery.join(', ')}
            WHERE version_id
            IN (
                SELECT version_id
                FROM ${historyTable}
                WHERE id = $id
                ORDER BY version_id DESC LIMIT 1
            )`;

        yield client.query_(query, parameters);
    };

    const getColumnNames = function* getColumnNames() {
        const columnNamesQuery = `
            SELECT column_name
            FROM information_schema.columns
            WHERE table_name = $tableName`;
        const entities = yield client.query_(columnNamesQuery, { tableName: table });

        return entities.rows.map(row => row.column_name);
    };

    return function* version(entity, trigger, newVersion) {
        const sanitizedEntity = Object.assign({}, entity);
        sanitizedEntity.version_trigger = trigger;

        if (['insert', 'update', 'delete'].indexOf(trigger) === -1) {
            throw new Error(`Unknown trigger status: ${trigger}`);
        }

        const columnNames = yield getColumnNames();

        if (!newVersion) {
            yield updateLastVersion(sanitizedEntity);
            return;
        }

        let numVersion = yield client.query_(`
            SELECT COUNT(version_id)
            FROM ${historyTable}
            WHERE id=$id
            GROUP BY id`, {
                id: sanitizedEntity.id,
            }.rows[0]);

        numVersion = numVersion ? numVersion.count : 0;
        numVersion++;

        const subSelect = `
            SELECT ${columnNames.join(', ')}, '${trigger}', '${numVersion}'
            FROM ${table}
            WHERE id = $id`;

        const query = `
            INSERT INTO ${historyTable} (
                ${columnNames.join(', ')},
                version_trigger,
                version
            ) (${subSelect})`;

        yield client.query_(query, { id: sanitizedEntity.id });
    };
};
